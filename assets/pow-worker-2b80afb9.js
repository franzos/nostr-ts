(function(){"use strict";var wt={};Object.defineProperty(wt,"__esModule",{value:!0}),wt.bech32m=wt.bech32=void 0;const bt="qpzry9x8gf2tvdw0s3jn54khce6mua7l",Ht={};for(let t=0;t<bt.length;t++){const e=bt.charAt(t);Ht[e]=t}function ct(t){const e=t>>25;return(t&33554431)<<5^-(e>>0&1)&996825010^-(e>>1&1)&642813549^-(e>>2&1)&513874426^-(e>>3&1)&1027748829^-(e>>4&1)&705979059}function qt(t){let e=1;for(let n=0;n<t.length;++n){const r=t.charCodeAt(n);if(r<33||r>126)return"Invalid prefix ("+t+")";e=ct(e)^r>>5}e=ct(e);for(let n=0;n<t.length;++n){const r=t.charCodeAt(n);e=ct(e)^r&31}return e}function mt(t,e,n,r){let o=0,s=0;const f=(1<<n)-1,a=[];for(let i=0;i<t.length;++i)for(o=o<<e|t[i],s+=e;s>=n;)s-=n,a.push(o>>s&f);if(r)s>0&&a.push(o<<n-s&f);else{if(s>=e)return"Excess padding";if(o<<n-s&f)return"Non-zero padding"}return a}function fe(t){return mt(t,8,5,!0)}function ae(t){const e=mt(t,5,8,!1);if(Array.isArray(e))return e}function ue(t){const e=mt(t,5,8,!1);if(Array.isArray(e))return e;throw new Error(e)}function _t(t){let e;t==="bech32"?e=1:e=734539939;function n(f,a,i){if(i=i||90,f.length+7+a.length>i)throw new TypeError("Exceeds length limit");f=f.toLowerCase();let h=qt(f);if(typeof h=="string")throw new Error(h);let m=f+"1";for(let g=0;g<a.length;++g){const x=a[g];if(x>>5)throw new Error("Non 5-bit word");h=ct(h)^x,m+=bt.charAt(x)}for(let g=0;g<6;++g)h=ct(h);h^=e;for(let g=0;g<6;++g){const x=h>>(5-g)*5&31;m+=bt.charAt(x)}return m}function r(f,a){if(a=a||90,f.length<8)return f+" too short";if(f.length>a)return"Exceeds length limit";const i=f.toLowerCase(),h=f.toUpperCase();if(f!==i&&f!==h)return"Mixed-case string "+f;f=i;const m=f.lastIndexOf("1");if(m===-1)return"No separator character for "+f;if(m===0)return"Missing prefix for "+f;const g=f.slice(0,m),x=f.slice(m+1);if(x.length<6)return"Data too short";let U=qt(g);if(typeof U=="string")return U;const A=[];for(let y=0;y<x.length;++y){const p=x.charAt(y),E=Ht[p];if(E===void 0)return"Unknown character "+p;U=ct(U)^E,!(y+6>=x.length)&&A.push(E)}return U!==e?"Invalid checksum for "+f:{prefix:g,words:A}}function o(f,a){const i=r(f,a);if(typeof i=="object")return i}function s(f,a){const i=r(f,a);if(typeof i=="object")return i;throw new Error(i)}return{decodeUnsafe:o,decode:s,encode:n,toWords:fe,fromWordsUnsafe:ae,fromWords:ue}}wt.bech32=_t("bech32"),wt.bech32m=_t("bech32m");var le={};(function(t){/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */Object.defineProperty(t,"__esModule",{value:!0}),t.bytes=t.stringToBytes=t.str=t.bytesToString=t.hex=t.utf8=t.bech32m=t.bech32=t.base58check=t.base58xmr=t.base58xrp=t.base58flickr=t.base58=t.base64url=t.base64=t.base32crockford=t.base32hex=t.base32=t.base16=t.utils=t.assertNumber=void 0;function e(c){if(!Number.isSafeInteger(c))throw new Error(`Wrong integer: ${c}`)}t.assertNumber=e;function n(...c){const l=(u,d)=>b=>u(d(b)),w=Array.from(c).reverse().reduce((u,d)=>u?l(u,d.encode):d.encode,void 0),B=c.reduce((u,d)=>u?l(u,d.decode):d.decode,void 0);return{encode:w,decode:B}}function r(c){return{encode:l=>{if(!Array.isArray(l)||l.length&&typeof l[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return l.map(w=>{if(e(w),w<0||w>=c.length)throw new Error(`Digit index outside alphabet: ${w} (alphabet: ${c.length})`);return c[w]})},decode:l=>{if(!Array.isArray(l)||l.length&&typeof l[0]!="string")throw new Error("alphabet.decode input should be array of strings");return l.map(w=>{if(typeof w!="string")throw new Error(`alphabet.decode: not string element=${w}`);const B=c.indexOf(w);if(B===-1)throw new Error(`Unknown letter: "${w}". Allowed: ${c}`);return B})}}}function o(c=""){if(typeof c!="string")throw new Error("join separator should be string");return{encode:l=>{if(!Array.isArray(l)||l.length&&typeof l[0]!="string")throw new Error("join.encode input should be array of strings");for(let w of l)if(typeof w!="string")throw new Error(`join.encode: non-string input=${w}`);return l.join(c)},decode:l=>{if(typeof l!="string")throw new Error("join.decode input should be string");return l.split(c)}}}function s(c,l="="){if(e(c),typeof l!="string")throw new Error("padding chr should be string");return{encode(w){if(!Array.isArray(w)||w.length&&typeof w[0]!="string")throw new Error("padding.encode input should be array of strings");for(let B of w)if(typeof B!="string")throw new Error(`padding.encode: non-string input=${B}`);for(;w.length*c%8;)w.push(l);return w},decode(w){if(!Array.isArray(w)||w.length&&typeof w[0]!="string")throw new Error("padding.encode input should be array of strings");for(let u of w)if(typeof u!="string")throw new Error(`padding.decode: non-string input=${u}`);let B=w.length;if(B*c%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;B>0&&w[B-1]===l;B--)if(!((B-1)*c%8))throw new Error("Invalid padding: string has too much padding");return w.slice(0,B)}}}function f(c){if(typeof c!="function")throw new Error("normalize fn should be function");return{encode:l=>l,decode:l=>c(l)}}function a(c,l,w){if(l<2)throw new Error(`convertRadix: wrong from=${l}, base cannot be less than 2`);if(w<2)throw new Error(`convertRadix: wrong to=${w}, base cannot be less than 2`);if(!Array.isArray(c))throw new Error("convertRadix: data should be array");if(!c.length)return[];let B=0;const u=[],d=Array.from(c);for(d.forEach(b=>{if(e(b),b<0||b>=l)throw new Error(`Wrong integer: ${b}`)});;){let b=0,L=!0;for(let N=B;N<d.length;N++){const _=d[N],T=l*b+_;if(!Number.isSafeInteger(T)||l*b/l!==b||T-_!==l*b)throw new Error("convertRadix: carry overflow");if(b=T%w,d[N]=Math.floor(T/w),!Number.isSafeInteger(d[N])||d[N]*w+b!==T)throw new Error("convertRadix: carry overflow");if(L)d[N]?L=!1:B=N;else continue}if(u.push(b),L)break}for(let b=0;b<c.length-1&&c[b]===0;b++)u.push(0);return u.reverse()}const i=(c,l)=>l?i(l,c%l):c,h=(c,l)=>c+(l-i(c,l));function m(c,l,w,B){if(!Array.isArray(c))throw new Error("convertRadix2: data should be array");if(l<=0||l>32)throw new Error(`convertRadix2: wrong from=${l}`);if(w<=0||w>32)throw new Error(`convertRadix2: wrong to=${w}`);if(h(l,w)>32)throw new Error(`convertRadix2: carry overflow from=${l} to=${w} carryBits=${h(l,w)}`);let u=0,d=0;const b=2**w-1,L=[];for(const N of c){if(e(N),N>=2**l)throw new Error(`convertRadix2: invalid data word=${N} from=${l}`);if(u=u<<l|N,d+l>32)throw new Error(`convertRadix2: carry overflow pos=${d} from=${l}`);for(d+=l;d>=w;d-=w)L.push((u>>d-w&b)>>>0);u&=2**d-1}if(u=u<<w-d&b,!B&&d>=l)throw new Error("Excess padding");if(!B&&u)throw new Error(`Non-zero padding: ${u}`);return B&&d>0&&L.push(u>>>0),L}function g(c){return e(c),{encode:l=>{if(!(l instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return a(Array.from(l),2**8,c)},decode:l=>{if(!Array.isArray(l)||l.length&&typeof l[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(a(l,c,2**8))}}}function x(c,l=!1){if(e(c),c<=0||c>32)throw new Error("radix2: bits should be in (0..32]");if(h(8,c)>32||h(c,8)>32)throw new Error("radix2: carry overflow");return{encode:w=>{if(!(w instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return m(Array.from(w),8,c,!l)},decode:w=>{if(!Array.isArray(w)||w.length&&typeof w[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(m(w,c,8,l))}}}function U(c){if(typeof c!="function")throw new Error("unsafeWrapper fn should be function");return function(...l){try{return c.apply(null,l)}catch{}}}function A(c,l){if(e(c),typeof l!="function")throw new Error("checksum fn should be function");return{encode(w){if(!(w instanceof Uint8Array))throw new Error("checksum.encode: input should be Uint8Array");const B=l(w).slice(0,c),u=new Uint8Array(w.length+c);return u.set(w),u.set(B,w.length),u},decode(w){if(!(w instanceof Uint8Array))throw new Error("checksum.decode: input should be Uint8Array");const B=w.slice(0,-c),u=l(B).slice(0,c),d=w.slice(-c);for(let b=0;b<c;b++)if(u[b]!==d[b])throw new Error("Invalid checksum");return B}}}t.utils={alphabet:r,chain:n,checksum:A,radix:g,radix2:x,join:o,padding:s},t.base16=n(x(4),r("0123456789ABCDEF"),o("")),t.base32=n(x(5),r("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),s(5),o("")),t.base32hex=n(x(5),r("0123456789ABCDEFGHIJKLMNOPQRSTUV"),s(5),o("")),t.base32crockford=n(x(5),r("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),o(""),f(c=>c.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1"))),t.base64=n(x(6),r("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),s(6),o("")),t.base64url=n(x(6),r("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),s(6),o(""));const y=c=>n(g(58),r(c),o(""));t.base58=y("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),t.base58flickr=y("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),t.base58xrp=y("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const p=[0,2,3,5,6,7,9,10,11];t.base58xmr={encode(c){let l="";for(let w=0;w<c.length;w+=8){const B=c.subarray(w,w+8);l+=t.base58.encode(B).padStart(p[B.length],"1")}return l},decode(c){let l=[];for(let w=0;w<c.length;w+=11){const B=c.slice(w,w+11),u=p.indexOf(B.length),d=t.base58.decode(B);for(let b=0;b<d.length-u;b++)if(d[b]!==0)throw new Error("base58xmr: wrong padding");l=l.concat(Array.from(d.slice(d.length-u)))}return Uint8Array.from(l)}};const E=c=>n(A(4,l=>c(c(l))),t.base58);t.base58check=E;const S=n(r("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),o("")),$=[996825010,642813549,513874426,1027748829,705979059];function C(c){const l=c>>25;let w=(c&33554431)<<5;for(let B=0;B<$.length;B++)(l>>B&1)===1&&(w^=$[B]);return w}function k(c,l,w=1){const B=c.length;let u=1;for(let d=0;d<B;d++){const b=c.charCodeAt(d);if(b<33||b>126)throw new Error(`Invalid prefix (${c})`);u=C(u)^b>>5}u=C(u);for(let d=0;d<B;d++)u=C(u)^c.charCodeAt(d)&31;for(let d of l)u=C(u)^d;for(let d=0;d<6;d++)u=C(u);return u^=w,S.encode(m([u%2**30],30,5,!1))}function v(c){const l=c==="bech32"?1:734539939,w=x(5),B=w.decode,u=w.encode,d=U(B);function b(T,H,Z=90){if(typeof T!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof T}`);if(!Array.isArray(H)||H.length&&typeof H[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof H}`);const V=T.length+7+H.length;if(Z!==!1&&V>Z)throw new TypeError(`Length ${V} exceeds limit ${Z}`);return T=T.toLowerCase(),`${T}1${S.encode(H)}${k(T,H,l)}`}function L(T,H=90){if(typeof T!="string")throw new Error(`bech32.decode input should be string, not ${typeof T}`);if(T.length<8||H!==!1&&T.length>H)throw new TypeError(`Wrong string length: ${T.length} (${T}). Expected (8..${H})`);const Z=T.toLowerCase();if(T!==Z&&T!==T.toUpperCase())throw new Error("String must be lowercase or uppercase");T=Z;const V=T.lastIndexOf("1");if(V===0||V===-1)throw new Error('Letter "1" must be present between prefix and data only');const X=T.slice(0,V),Q=T.slice(V+1);if(Q.length<6)throw new Error("Data must be at least 6 characters long");const G=S.decode(Q).slice(0,-6),ut=k(X,G,l);if(!Q.endsWith(ut))throw new Error(`Invalid checksum in ${T}: expected "${ut}"`);return{prefix:X,words:G}}const N=U(L);function _(T){const{prefix:H,words:Z}=L(T,!1);return{prefix:H,words:Z,bytes:B(Z)}}return{encode:b,decode:L,decodeToBytes:_,decodeUnsafe:N,fromWords:B,fromWordsUnsafe:d,toWords:u}}t.bech32=v("bech32"),t.bech32m=v("bech32m"),t.utf8={encode:c=>new TextDecoder().decode(c),decode:c=>new TextEncoder().encode(c)},t.hex=n(x(4),r("0123456789abcdef"),o(""),f(c=>{if(typeof c!="string"||c.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof c} with length ${c.length}`);return c.toLowerCase()}));const I={utf8:t.utf8,hex:t.hex,base16:t.base16,base32:t.base32,base64:t.base64,base64url:t.base64url,base58:t.base58,base58xmr:t.base58xmr},O=`Invalid encoding type. Available types: ${Object.keys(I).join(", ")}`,D=(c,l)=>{if(typeof c!="string"||!I.hasOwnProperty(c))throw new TypeError(O);if(!(l instanceof Uint8Array))throw new TypeError("bytesToString() expects Uint8Array");return I[c].encode(l)};t.bytesToString=D,t.str=t.bytesToString;const q=(c,l)=>{if(!I.hasOwnProperty(c))throw new TypeError(O);if(typeof l!="string")throw new TypeError("stringToBytes() expects string");return I[c].decode(l)};t.stringToBytes=q,t.bytes=t.stringToBytes})(le),BigInt(1e3),BigInt(1e6),BigInt(1e9),BigInt(1e12),BigInt("2100000000000000000"),BigInt(1e11);const Rt={payment_hash:1,payment_secret:16,description:13,payee:19,description_hash:23,expiry:6,min_final_cltv_expiry:24,fallback_address:9,route_hint:3,feature_bits:5,metadata:27};for(let t=0,e=Object.keys(Rt);t<e.length;t++)e[t],Rt[e[t]].toString();function xt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function de(t){if(typeof t!="boolean")throw new Error(`Expected boolean, not ${t}`)}function jt(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function he(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");xt(t.outputLen),xt(t.blockLen)}function we(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function ge(t,e){jt(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const et={number:xt,bool:de,bytes:jt,hash:he,exists:we,output:ge},Bt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Zt=t=>t instanceof Uint8Array,At=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),K=(t,e)=>t<<32-e|t>>>e;if(!(new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68))throw new Error("Non little-endian hardware is not supported");Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function ye(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function vt(t){if(typeof t=="string"&&(t=ye(t)),!Zt(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function be(...t){const e=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let n=0;return t.forEach(r=>{if(!Zt(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}class Vt{clone(){return this._cloneInto()}}function zt(t){const e=r=>t().update(vt(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function pe(t=32){if(Bt&&typeof Bt.getRandomValues=="function")return Bt.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function Ee(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const o=BigInt(32),s=BigInt(4294967295),f=Number(n>>o&s),a=Number(n&s),i=r?4:0,h=r?0:4;t.setUint32(e+i,f,r),t.setUint32(e+h,a,r)}class me extends Vt{constructor(e,n,r,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=At(this.buffer)}update(e){et.exists(this);const{view:n,buffer:r,blockLen:o}=this;e=vt(e);const s=e.length;for(let f=0;f<s;){const a=Math.min(o-this.pos,s-f);if(a===o){const i=At(e);for(;o<=s-f;f+=o)this.process(i,f);continue}r.set(e.subarray(f,f+a),this.pos),this.pos+=a,f+=a,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){et.exists(this),et.output(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:f}=this;n[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>o-f&&(this.process(r,0),f=0);for(let g=f;g<o;g++)n[g]=0;Ee(r,o-8,BigInt(this.length*8),s),this.process(r,0);const a=At(e),i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=i/4,m=this.get();if(h>m.length)throw new Error("_sha2: outputLen bigger than state");for(let g=0;g<h;g++)a.setUint32(4*g,m[g],s)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:f,pos:a}=this;return e.length=o,e.pos=a,e.finished=s,e.destroyed=f,o%n&&e.buffer.set(r),e}}const xe=(t,e,n)=>t&e^~t&n,Be=(t,e,n)=>t&e^t&n^e&n,Ae=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),J=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),tt=new Uint32Array(64);class Dt extends me{constructor(){super(64,32,8,!1),this.A=J[0]|0,this.B=J[1]|0,this.C=J[2]|0,this.D=J[3]|0,this.E=J[4]|0,this.F=J[5]|0,this.G=J[6]|0,this.H=J[7]|0}get(){const{A:e,B:n,C:r,D:o,E:s,F:f,G:a,H:i}=this;return[e,n,r,o,s,f,a,i]}set(e,n,r,o,s,f,a,i){this.A=e|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=f|0,this.G=a|0,this.H=i|0}process(e,n){for(let g=0;g<16;g++,n+=4)tt[g]=e.getUint32(n,!1);for(let g=16;g<64;g++){const x=tt[g-15],U=tt[g-2],A=K(x,7)^K(x,18)^x>>>3,y=K(U,17)^K(U,19)^U>>>10;tt[g]=y+tt[g-7]+A+tt[g-16]|0}let{A:r,B:o,C:s,D:f,E:a,F:i,G:h,H:m}=this;for(let g=0;g<64;g++){const x=K(a,6)^K(a,11)^K(a,25),U=m+x+xe(a,i,h)+Ae[g]+tt[g]|0,y=(K(r,2)^K(r,13)^K(r,22))+Be(r,o,s)|0;m=h,h=i,i=a,a=f+U|0,f=s,s=o,o=r,r=U+y|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,f=f+this.D|0,a=a+this.E|0,i=i+this.F|0,h=h+this.G|0,m=m+this.H|0,this.set(r,o,s,f,a,i,h,m)}roundClean(){tt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class ve extends Dt{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const Pt=zt(()=>new Dt);zt(()=>new ve);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Wt=BigInt(0),pt=BigInt(1),Se=BigInt(2),Et=t=>t instanceof Uint8Array,Ie=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function nt(t){if(!Et(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=Ie[t[n]];return e}function Yt(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function St(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function ft(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(e/2);for(let r=0;r<n.length;r++){const o=r*2,s=t.slice(o,o+2),f=Number.parseInt(s,16);if(Number.isNaN(f)||f<0)throw new Error("Invalid byte sequence");n[r]=f}return n}function rt(t){return St(nt(t))}function It(t){if(!Et(t))throw new Error("Uint8Array expected");return St(nt(Uint8Array.from(t).reverse()))}function at(t,e){return ft(t.toString(16).padStart(e*2,"0"))}function Gt(t,e){return at(t,e).reverse()}function Te(t){return ft(Yt(t))}function P(t,e,n){let r;if(typeof e=="string")try{r=ft(e)}catch(s){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${s}`)}else if(Et(e))r=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);const o=r.length;if(typeof n=="number"&&o!==n)throw new Error(`${t} expected ${n} bytes, got ${o}`);return r}function gt(...t){const e=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let n=0;return t.forEach(r=>{if(!Et(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}function $e(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function Ne(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Ue(t){let e;for(e=0;t>Wt;t>>=pt,e+=1);return e}function Oe(t,e){return t>>BigInt(e)&pt}const ke=(t,e,n)=>t|(n?pt:Wt)<<BigInt(e),Tt=t=>(Se<<BigInt(t-1))-pt,$t=t=>new Uint8Array(t),Mt=t=>Uint8Array.from(t);function Kt(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=$t(t),o=$t(t),s=0;const f=()=>{r.fill(1),o.fill(0),s=0},a=(...g)=>n(o,r,...g),i=(g=$t())=>{o=a(Mt([0]),g),r=a(),g.length!==0&&(o=a(Mt([1]),g),r=a())},h=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let g=0;const x=[];for(;g<e;){r=a();const U=r.slice();x.push(U),g+=r.length}return gt(...x)};return(g,x)=>{f(),i(g);let U;for(;!(U=x(h()));)i();return f(),U}}const Le={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function yt(t,e,n={}){const r=(o,s,f)=>{const a=Le[s];if(typeof a!="function")throw new Error(`Invalid validator "${s}", expected function`);const i=t[o];if(!(f&&i===void 0)&&!a(i,t))throw new Error(`Invalid param ${String(o)}=${i} (${typeof i}), expected ${s}`)};for(const[o,s]of Object.entries(e))r(o,s,!1);for(const[o,s]of Object.entries(n))r(o,s,!0);return t}var Ce=Object.freeze({__proto__:null,bitGet:Oe,bitLen:Ue,bitMask:Tt,bitSet:ke,bytesToHex:nt,bytesToNumberBE:rt,bytesToNumberLE:It,concatBytes:gt,createHmacDrbg:Kt,ensureBytes:P,equalBytes:$e,hexToBytes:ft,hexToNumber:St,numberToBytesBE:at,numberToBytesLE:Gt,numberToHexUnpadded:Yt,numberToVarBytesBE:Te,utf8ToBytes:Ne,validateObject:yt});/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const j=BigInt(0),R=BigInt(1),ot=BigInt(2),He=BigInt(3),Nt=BigInt(4),Ft=BigInt(5),Xt=BigInt(8);BigInt(9),BigInt(16);function z(t,e){const n=t%e;return n>=j?n:e+n}function qe(t,e,n){if(n<=j||e<j)throw new Error("Expected power/modulo > 0");if(n===R)return j;let r=R;for(;e>j;)e&R&&(r=r*t%n),t=t*t%n,e>>=R;return r}function W(t,e,n){let r=t;for(;e-- >j;)r*=r,r%=n;return r}function Ut(t,e){if(t===j||e<=j)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=z(t,e),r=e,o=j,s=R;for(;n!==j;){const a=r/n,i=r%n,h=o-s*a;r=n,n=i,o=s,s=h}if(r!==R)throw new Error("invert: does not exist");return z(o,e)}function _e(t){const e=(t-R)/ot;let n,r,o;for(n=t-R,r=0;n%ot===j;n/=ot,r++);for(o=ot;o<t&&qe(o,e,t)!==t-R;o++);if(r===1){const f=(t+R)/Nt;return function(i,h){const m=i.pow(h,f);if(!i.eql(i.sqr(m),h))throw new Error("Cannot find square root");return m}}const s=(n+R)/ot;return function(a,i){if(a.pow(i,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let h=r,m=a.pow(a.mul(a.ONE,o),n),g=a.pow(i,s),x=a.pow(i,n);for(;!a.eql(x,a.ONE);){if(a.eql(x,a.ZERO))return a.ZERO;let U=1;for(let y=a.sqr(x);U<h&&!a.eql(y,a.ONE);U++)y=a.sqr(y);const A=a.pow(m,R<<BigInt(h-U-1));m=a.sqr(A),g=a.mul(g,A),x=a.mul(x,m),h=U}return g}}function Re(t){if(t%Nt===He){const e=(t+R)/Nt;return function(r,o){const s=r.pow(o,e);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(t%Xt===Ft){const e=(t-Ft)/Xt;return function(r,o){const s=r.mul(o,ot),f=r.pow(s,e),a=r.mul(o,f),i=r.mul(r.mul(a,ot),f),h=r.mul(a,r.sub(i,r.ONE));if(!r.eql(r.sqr(h),o))throw new Error("Cannot find square root");return h}}return _e(t)}const je=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ze(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=je.reduce((r,o)=>(r[o]="function",r),e);return yt(t,n)}function Ve(t,e,n){if(n<j)throw new Error("Expected power > 0");if(n===j)return t.ONE;if(n===R)return e;let r=t.ONE,o=e;for(;n>j;)n&R&&(r=t.mul(r,o)),o=t.sqr(o),n>>=R;return r}function ze(t,e){const n=new Array(e.length),r=e.reduce((s,f,a)=>t.is0(f)?s:(n[a]=s,t.mul(s,f)),t.ONE),o=t.inv(r);return e.reduceRight((s,f,a)=>t.is0(f)?s:(n[a]=t.mul(s,n[a]),t.mul(s,f)),o),n}function Ot(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function De(t,e,n=!1,r={}){if(t<=j)throw new Error(`Expected Fp ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:s}=Ot(t,e);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const f=Re(t),a=Object.freeze({ORDER:t,BITS:o,BYTES:s,MASK:Tt(o),ZERO:j,ONE:R,create:i=>z(i,t),isValid:i=>{if(typeof i!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof i}`);return j<=i&&i<t},is0:i=>i===j,isOdd:i=>(i&R)===R,neg:i=>z(-i,t),eql:(i,h)=>i===h,sqr:i=>z(i*i,t),add:(i,h)=>z(i+h,t),sub:(i,h)=>z(i-h,t),mul:(i,h)=>z(i*h,t),pow:(i,h)=>Ve(a,i,h),div:(i,h)=>z(i*Ut(h,t),t),sqrN:i=>i*i,addN:(i,h)=>i+h,subN:(i,h)=>i-h,mulN:(i,h)=>i*h,inv:i=>Ut(i,t),sqrt:r.sqrt||(i=>f(a,i)),invertBatch:i=>ze(a,i),cmov:(i,h,m)=>m?h:i,toBytes:i=>n?Gt(i,s):at(i,s),fromBytes:i=>{if(i.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${i.length}`);return n?It(i):rt(i)}});return Object.freeze(a)}function Pe(t,e,n=!1){t=P("privateHash",t);const r=t.length,o=Ot(e).nByteLength+8;if(o<24||r<o||r>1024)throw new Error(`hashToPrivateScalar: expected ${o}-1024 bytes of input, got ${r}`);const s=n?It(t):rt(t);return z(s,e-R)+R}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const We=BigInt(0),kt=BigInt(1);function Ye(t,e){const n=(o,s)=>{const f=s.negate();return o?f:s},r=o=>{const s=Math.ceil(e/o)+1,f=2**(o-1);return{windows:s,windowSize:f}};return{constTimeNegate:n,unsafeLadder(o,s){let f=t.ZERO,a=o;for(;s>We;)s&kt&&(f=f.add(a)),a=a.double(),s>>=kt;return f},precomputeWindow(o,s){const{windows:f,windowSize:a}=r(s),i=[];let h=o,m=h;for(let g=0;g<f;g++){m=h,i.push(m);for(let x=1;x<a;x++)m=m.add(h),i.push(m);h=m.double()}return i},wNAF(o,s,f){const{windows:a,windowSize:i}=r(o);let h=t.ZERO,m=t.BASE;const g=BigInt(2**o-1),x=2**o,U=BigInt(o);for(let A=0;A<a;A++){const y=A*i;let p=Number(f&g);f>>=U,p>i&&(p-=x,f+=kt);const E=y,S=y+Math.abs(p)-1,$=A%2!==0,C=p<0;p===0?m=m.add(n($,s[E])):h=h.add(n(C,s[S]))}return{p:h,f:m}},wNAFCached(o,s,f,a){const i=o._WINDOW_SIZE||1;let h=s.get(o);return h||(h=this.precomputeWindow(o,i),i!==1&&s.set(o,a(h))),this.wNAF(i,h,f)}}}function Qt(t){return Ze(t.Fp),yt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ot(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ge(t){const e=Qt(t);yt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:Me,hexToBytes:Ke}=Ce,it={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(t){const{Err:e}=it;if(t.length<2||t[0]!==2)throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:Me(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=it,n=typeof t=="string"?Ke(t):t;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let r=n.length;if(r<2||n[0]!=48)throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:o,l:s}=it._parseInt(n.subarray(2)),{d:f,l:a}=it._parseInt(s);if(a.length)throw new e("Invalid signature: left bytes after parsing");return{r:o,s:f}},hexFromSig(t){const e=h=>Number.parseInt(h[0],16)&8?"00"+h:h,n=h=>{const m=h.toString(16);return m.length&1?`0${m}`:m},r=e(n(t.s)),o=e(n(t.r)),s=r.length/2,f=o.length/2,a=n(s),i=n(f);return`30${n(f+s+4)}02${i}${o}02${a}${r}`}},F=BigInt(0),Y=BigInt(1);BigInt(2);const Jt=BigInt(3);BigInt(4);function Fe(t){const e=Ge(t),{Fp:n}=e,r=e.toBytes||((A,y,p)=>{const E=y.toAffine();return gt(Uint8Array.from([4]),n.toBytes(E.x),n.toBytes(E.y))}),o=e.fromBytes||(A=>{const y=A.subarray(1),p=n.fromBytes(y.subarray(0,n.BYTES)),E=n.fromBytes(y.subarray(n.BYTES,2*n.BYTES));return{x:p,y:E}});function s(A){const{a:y,b:p}=e,E=n.sqr(A),S=n.mul(E,A);return n.add(n.add(S,n.mul(A,y)),p)}if(!n.eql(n.sqr(e.Gy),s(e.Gx)))throw new Error("bad generator point: equation left != right");function f(A){return typeof A=="bigint"&&F<A&&A<e.n}function a(A){if(!f(A))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function i(A){const{allowedPrivateKeyLengths:y,nByteLength:p,wrapPrivateKey:E,n:S}=e;if(y&&typeof A!="bigint"){if(A instanceof Uint8Array&&(A=nt(A)),typeof A!="string"||!y.includes(A.length))throw new Error("Invalid key");A=A.padStart(p*2,"0")}let $;try{$=typeof A=="bigint"?A:rt(P("private key",A,p))}catch{throw new Error(`private key must be ${p} bytes, hex or bigint, not ${typeof A}`)}return E&&($=z($,S)),a($),$}const h=new Map;function m(A){if(!(A instanceof g))throw new Error("ProjectivePoint expected")}class g{constructor(y,p,E){if(this.px=y,this.py=p,this.pz=E,y==null||!n.isValid(y))throw new Error("x required");if(p==null||!n.isValid(p))throw new Error("y required");if(E==null||!n.isValid(E))throw new Error("z required")}static fromAffine(y){const{x:p,y:E}=y||{};if(!y||!n.isValid(p)||!n.isValid(E))throw new Error("invalid affine point");if(y instanceof g)throw new Error("projective point not allowed");const S=$=>n.eql($,n.ZERO);return S(p)&&S(E)?g.ZERO:new g(p,E,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(y){const p=n.invertBatch(y.map(E=>E.pz));return y.map((E,S)=>E.toAffine(p[S])).map(g.fromAffine)}static fromHex(y){const p=g.fromAffine(o(P("pointHex",y)));return p.assertValidity(),p}static fromPrivateKey(y){return g.BASE.multiply(i(y))}_setWindowSize(y){this._WINDOW_SIZE=y,h.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint)return;throw new Error("bad point: ZERO")}const{x:y,y:p}=this.toAffine();if(!n.isValid(y)||!n.isValid(p))throw new Error("bad point: x or y not FE");const E=n.sqr(p),S=s(y);if(!n.eql(E,S))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y}=this.toAffine();if(n.isOdd)return!n.isOdd(y);throw new Error("Field doesn't support isOdd")}equals(y){m(y);const{px:p,py:E,pz:S}=this,{px:$,py:C,pz:k}=y,v=n.eql(n.mul(p,k),n.mul($,S)),I=n.eql(n.mul(E,k),n.mul(C,S));return v&&I}negate(){return new g(this.px,n.neg(this.py),this.pz)}double(){const{a:y,b:p}=e,E=n.mul(p,Jt),{px:S,py:$,pz:C}=this;let k=n.ZERO,v=n.ZERO,I=n.ZERO,O=n.mul(S,S),D=n.mul($,$),q=n.mul(C,C),c=n.mul(S,$);return c=n.add(c,c),I=n.mul(S,C),I=n.add(I,I),k=n.mul(y,I),v=n.mul(E,q),v=n.add(k,v),k=n.sub(D,v),v=n.add(D,v),v=n.mul(k,v),k=n.mul(c,k),I=n.mul(E,I),q=n.mul(y,q),c=n.sub(O,q),c=n.mul(y,c),c=n.add(c,I),I=n.add(O,O),O=n.add(I,O),O=n.add(O,q),O=n.mul(O,c),v=n.add(v,O),q=n.mul($,C),q=n.add(q,q),O=n.mul(q,c),k=n.sub(k,O),I=n.mul(q,D),I=n.add(I,I),I=n.add(I,I),new g(k,v,I)}add(y){m(y);const{px:p,py:E,pz:S}=this,{px:$,py:C,pz:k}=y;let v=n.ZERO,I=n.ZERO,O=n.ZERO;const D=e.a,q=n.mul(e.b,Jt);let c=n.mul(p,$),l=n.mul(E,C),w=n.mul(S,k),B=n.add(p,E),u=n.add($,C);B=n.mul(B,u),u=n.add(c,l),B=n.sub(B,u),u=n.add(p,S);let d=n.add($,k);return u=n.mul(u,d),d=n.add(c,w),u=n.sub(u,d),d=n.add(E,S),v=n.add(C,k),d=n.mul(d,v),v=n.add(l,w),d=n.sub(d,v),O=n.mul(D,u),v=n.mul(q,w),O=n.add(v,O),v=n.sub(l,O),O=n.add(l,O),I=n.mul(v,O),l=n.add(c,c),l=n.add(l,c),w=n.mul(D,w),u=n.mul(q,u),l=n.add(l,w),w=n.sub(c,w),w=n.mul(D,w),u=n.add(u,w),c=n.mul(l,u),I=n.add(I,c),c=n.mul(d,u),v=n.mul(B,v),v=n.sub(v,c),c=n.mul(B,l),O=n.mul(d,O),O=n.add(O,c),new g(v,I,O)}subtract(y){return this.add(y.negate())}is0(){return this.equals(g.ZERO)}wNAF(y){return U.wNAFCached(this,h,y,p=>{const E=n.invertBatch(p.map(S=>S.pz));return p.map((S,$)=>S.toAffine(E[$])).map(g.fromAffine)})}multiplyUnsafe(y){const p=g.ZERO;if(y===F)return p;if(a(y),y===Y)return this;const{endo:E}=e;if(!E)return U.unsafeLadder(this,y);let{k1neg:S,k1:$,k2neg:C,k2:k}=E.splitScalar(y),v=p,I=p,O=this;for(;$>F||k>F;)$&Y&&(v=v.add(O)),k&Y&&(I=I.add(O)),O=O.double(),$>>=Y,k>>=Y;return S&&(v=v.negate()),C&&(I=I.negate()),I=new g(n.mul(I.px,E.beta),I.py,I.pz),v.add(I)}multiply(y){a(y);let p=y,E,S;const{endo:$}=e;if($){const{k1neg:C,k1:k,k2neg:v,k2:I}=$.splitScalar(p);let{p:O,f:D}=this.wNAF(k),{p:q,f:c}=this.wNAF(I);O=U.constTimeNegate(C,O),q=U.constTimeNegate(v,q),q=new g(n.mul(q.px,$.beta),q.py,q.pz),E=O.add(q),S=D.add(c)}else{const{p:C,f:k}=this.wNAF(p);E=C,S=k}return g.normalizeZ([E,S])[0]}multiplyAndAddUnsafe(y,p,E){const S=g.BASE,$=(k,v)=>v===F||v===Y||!k.equals(S)?k.multiplyUnsafe(v):k.multiply(v),C=$(this,p).add($(y,E));return C.is0()?void 0:C}toAffine(y){const{px:p,py:E,pz:S}=this,$=this.is0();y==null&&(y=$?n.ONE:n.inv(S));const C=n.mul(p,y),k=n.mul(E,y),v=n.mul(S,y);if($)return{x:n.ZERO,y:n.ZERO};if(!n.eql(v,n.ONE))throw new Error("invZ was invalid");return{x:C,y:k}}isTorsionFree(){const{h:y,isTorsionFree:p}=e;if(y===Y)return!0;if(p)return p(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:y,clearCofactor:p}=e;return y===Y?this:p?p(g,this):this.multiplyUnsafe(e.h)}toRawBytes(y=!0){return this.assertValidity(),r(g,this,y)}toHex(y=!0){return nt(this.toRawBytes(y))}}g.BASE=new g(e.Gx,e.Gy,n.ONE),g.ZERO=new g(n.ZERO,n.ONE,n.ZERO);const x=e.nBitLength,U=Ye(g,e.endo?Math.ceil(x/2):x);return{CURVE:e,ProjectivePoint:g,normPrivateKeyToScalar:i,weierstrassEquation:s,isWithinCurveOrder:f}}function Xe(t){const e=Qt(t);return yt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Qe(t){const e=Xe(t),{Fp:n,n:r}=e,o=n.BYTES+1,s=2*n.BYTES+1;function f(u){return F<u&&u<n.ORDER}function a(u){return z(u,r)}function i(u){return Ut(u,r)}const{ProjectivePoint:h,normPrivateKeyToScalar:m,weierstrassEquation:g,isWithinCurveOrder:x}=Fe({...e,toBytes(u,d,b){const L=d.toAffine(),N=n.toBytes(L.x),_=gt;return b?_(Uint8Array.from([d.hasEvenY()?2:3]),N):_(Uint8Array.from([4]),N,n.toBytes(L.y))},fromBytes(u){const d=u.length,b=u[0],L=u.subarray(1);if(d===o&&(b===2||b===3)){const N=rt(L);if(!f(N))throw new Error("Point is not on curve");const _=g(N);let T=n.sqrt(_);const H=(T&Y)===Y;return(b&1)===1!==H&&(T=n.neg(T)),{x:N,y:T}}else if(d===s&&b===4){const N=n.fromBytes(L.subarray(0,n.BYTES)),_=n.fromBytes(L.subarray(n.BYTES,2*n.BYTES));return{x:N,y:_}}else throw new Error(`Point of length ${d} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}}),U=u=>nt(at(u,e.nByteLength));function A(u){const d=r>>Y;return u>d}function y(u){return A(u)?a(-u):u}const p=(u,d,b)=>rt(u.slice(d,b));class E{constructor(d,b,L){this.r=d,this.s=b,this.recovery=L,this.assertValidity()}static fromCompact(d){const b=e.nByteLength;return d=P("compactSignature",d,b*2),new E(p(d,0,b),p(d,b,2*b))}static fromDER(d){const{r:b,s:L}=it.toSig(P("DER",d));return new E(b,L)}assertValidity(){if(!x(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!x(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(d){return new E(this.r,this.s,d)}recoverPublicKey(d){const{r:b,s:L,recovery:N}=this,_=I(P("msgHash",d));if(N==null||![0,1,2,3].includes(N))throw new Error("recovery id invalid");const T=N===2||N===3?b+e.n:b;if(T>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const H=N&1?"03":"02",Z=h.fromHex(H+U(T)),V=i(T),X=a(-_*V),Q=a(L*V),G=h.BASE.multiplyAndAddUnsafe(Z,X,Q);if(!G)throw new Error("point at infinify");return G.assertValidity(),G}hasHighS(){return A(this.s)}normalizeS(){return this.hasHighS()?new E(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return ft(this.toDERHex())}toDERHex(){return it.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ft(this.toCompactHex())}toCompactHex(){return U(this.r)+U(this.s)}}const S={isValidPrivateKey(u){try{return m(u),!0}catch{return!1}},normPrivateKeyToScalar:m,randomPrivateKey:()=>{const u=e.randomBytes(n.BYTES+8),d=Pe(u,r);return at(d,e.nByteLength)},precompute(u=8,d=h.BASE){return d._setWindowSize(u),d.multiply(BigInt(3)),d}};function $(u,d=!0){return h.fromPrivateKey(u).toRawBytes(d)}function C(u){const d=u instanceof Uint8Array,b=typeof u=="string",L=(d||b)&&u.length;return d?L===o||L===s:b?L===2*o||L===2*s:u instanceof h}function k(u,d,b=!0){if(C(u))throw new Error("first arg must be private key");if(!C(d))throw new Error("second arg must be public key");return h.fromHex(d).multiply(m(u)).toRawBytes(b)}const v=e.bits2int||function(u){const d=rt(u),b=u.length*8-e.nBitLength;return b>0?d>>BigInt(b):d},I=e.bits2int_modN||function(u){return a(v(u))},O=Tt(e.nBitLength);function D(u){if(typeof u!="bigint")throw new Error("bigint expected");if(!(F<=u&&u<O))throw new Error(`bigint expected < 2^${e.nBitLength}`);return at(u,e.nByteLength)}function q(u,d,b=c){if(["recovered","canonical"].some(st=>st in b))throw new Error("sign() legacy options not supported");const{hash:L,randomBytes:N}=e;let{lowS:_,prehash:T,extraEntropy:H}=b;_==null&&(_=!0),u=P("msgHash",u),T&&(u=P("prehashed msgHash",L(u)));const Z=I(u),V=m(d),X=[D(V),D(Z)];if(H!=null){const st=H===!0?N(n.BYTES):H;X.push(P("extraEntropy",st,n.BYTES))}const Q=gt(...X),G=Z;function ut(st){const lt=v(st);if(!x(lt))return;const ie=i(lt),dt=h.BASE.multiply(lt).toAffine(),M=a(dt.x);if(M===F)return;const ht=a(ie*a(G+M*V));if(ht===F)return;let se=(dt.x===M?0:2)|Number(dt.y&Y),ce=ht;return _&&A(ht)&&(ce=y(ht),se^=1),new E(M,ce,se)}return{seed:Q,k2sig:ut}}const c={lowS:e.lowS,prehash:!1},l={lowS:e.lowS,prehash:!1};function w(u,d,b=c){const{seed:L,k2sig:N}=q(u,d,b),_=e;return Kt(_.hash.outputLen,_.nByteLength,_.hmac)(L,N)}h.BASE._setWindowSize(8);function B(u,d,b,L=l){var dt;const N=u;if(d=P("msgHash",d),b=P("publicKey",b),"strict"in L)throw new Error("options.strict was renamed to lowS");const{lowS:_,prehash:T}=L;let H,Z;try{if(typeof N=="string"||N instanceof Uint8Array)try{H=E.fromDER(N)}catch(M){if(!(M instanceof it.Err))throw M;H=E.fromCompact(N)}else if(typeof N=="object"&&typeof N.r=="bigint"&&typeof N.s=="bigint"){const{r:M,s:ht}=N;H=new E(M,ht)}else throw new Error("PARSE");Z=h.fromHex(b)}catch(M){if(M.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(_&&H.hasHighS())return!1;T&&(d=e.hash(d));const{r:V,s:X}=H,Q=I(d),G=i(X),ut=a(Q*G),st=a(V*G),lt=(dt=h.BASE.multiplyAndAddUnsafe(Z,ut,st))==null?void 0:dt.toAffine();return lt?a(lt.x)===V:!1}return{CURVE:e,getPublicKey:$,getSharedSecret:k,sign:w,verify:B,ProjectivePoint:h,Signature:E,utils:S}}class te extends Vt{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,et.hash(e);const r=vt(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?e.create().update(r).digest():r);for(let f=0;f<s.length;f++)s[f]^=54;this.iHash.update(s),this.oHash=e.create();for(let f=0;f<s.length;f++)s[f]^=106;this.oHash.update(s),s.fill(0)}update(e){return et.exists(this),this.iHash.update(e),this}digestInto(e){et.exists(this),et.bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:f,outputLen:a}=this;return e=e,e.finished=o,e.destroyed=s,e.blockLen=f,e.outputLen=a,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ee=(t,e,n)=>new te(t,e).update(n).digest();ee.create=(t,e)=>new te(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Je(t){return{hash:t,hmac:(e,...n)=>ee(t,e,be(...n)),randomBytes:pe}}function tn(t,e){const n=r=>Qe({...t,...Je(r)});return Object.freeze({...n(e),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ne=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),re=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),en=BigInt(1),Lt=BigInt(2),oe=(t,e)=>(t+e/Lt)/e;function nn(t){const e=ne,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),f=BigInt(23),a=BigInt(44),i=BigInt(88),h=t*t*t%e,m=h*h*t%e,g=W(m,n,e)*m%e,x=W(g,n,e)*m%e,U=W(x,Lt,e)*h%e,A=W(U,o,e)*U%e,y=W(A,s,e)*A%e,p=W(y,a,e)*y%e,E=W(p,i,e)*p%e,S=W(E,a,e)*y%e,$=W(S,n,e)*m%e,C=W($,f,e)*A%e,k=W(C,r,e)*h%e,v=W(k,Lt,e);if(!Ct.eql(Ct.sqr(v),t))throw new Error("Cannot find square root");return v}const Ct=De(ne,void 0,void 0,{sqrt:nn}),rn=tn({a:BigInt(0),b:BigInt(7),Fp:Ct,n:re,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=re,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-en*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,f=BigInt("0x100000000000000000000000000000000"),a=oe(s*t,e),i=oe(-r*t,e);let h=z(t-a*n-i*o,e),m=z(-a*r-i*s,e);const g=h>f,x=m>f;if(g&&(h=e-h),x&&(m=e-m),h>f||m>f)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:g,k1:h,k2neg:x,k2:m}}}},Pt);BigInt(0),rn.ProjectivePoint;var on=new TextEncoder;new TextDecoder("utf-8");function sn(t){const e=Pt(on.encode(t));return nt(e)}new TextEncoder,new TextDecoder;function cn(t){let e=0;for(let n=0;n<t.length;n++){const r=parseInt(t[n],16);if(r===0)e+=4;else{e+=Math.clz32(r)-28;break}}return e}function fn(t,e,n){let r=0;const o=e.toString();for(;;){const s=t.tags.findIndex(i=>i[0]==="nonce");s!==-1?t.tags[s][1]=r.toString():t.tags.push(["nonce",r.toString(),o]);const f=JSON.stringify([0,t.pubkey,t.created_at,t.kind,t.tags,t.content]);if(t.id=sn(f),cn(t.id)>=e)return console.log("Proof of work complete"),t.tags=t.tags.filter(i=>i[0]!=="nonce"),t.tags.push(["nonce",r.toString(),o]),t;if(n&&r>=n)return;r++}}self.onmessage=function(t){const e=t.data,n=fn(e.event,e.bits);self.postMessage({result:n})}})();
